<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprQuickMan</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

name = "QUICK MAN"
level = rmQuick;
var Col1,Col2;
Col1 = 18;
Col2 = 17;
introBGCol = make_color_rgb(global.nesPalette[Col1, 0], global.nesPalette[Col1, 1], global.nesPalette[Col1, 2]);
introLineCol = make_color_rgb(global.nesPalette[Col2, 0], global.nesPalette[Col2, 1], global.nesPalette[Col2, 2]);
standSprite = sprQuickStand;
pose = sprQuickPose;
poseImgSpeed = 12/60;
weaponID = objMetalBladeWeapon;
bossID = 1; //The ID on the stage select screen. The top-left has an ID of 0, then it goes clockwise (so the left panel's ID is 7)
            //The middle panel's ID is 8
            
contactDamage = 4;

global.weaponID = weaponID;
global.bossID = bossID;

damage[objTimeSlow] = 1;

ground = false;

phase = 0;
phaseTimer = 0; //The number of frames passed since the start of the phase
run_speed = 2;
run_time = 60;
xDistanceTravelled = 0; // how far the RM has moved, ever
jump_count = 0;
has_fired = false;

//how high Quick Man jumps:
jump_height_for[0] = 32;
jump_height_for[1] = 96;
jump_height_for[2] = 128;

// affects where Quick Man tries to land next to player (positive means jumping past player)
jump_x_offset[0] = -32;
jump_x_offset[1] = 0;
jump_x_offset[2] = 32;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if !global.frozen /*&amp;&amp; !global.flashStopper*/
{
    if isFight {
        //Set weakness to being slowed by Time Stopper
        if update_rate &lt; 1 {
            damage[objBusterShot] = 3;
        }else{
            //default boss damages
            damage[objBusterShot] = 1;
        }
        //unaffected ratios
        damage[objBassBusterShot] = 0.5*damage[objBusterShot];
        
        image_speed = 0;
        sprite_index = sprQuickMan;

        checkGround();
        gravityCheckGround();
        
        //keep track of phase at start of step in case it changes
        startPhase = phase;
        
        //initialize so we only have to declare in phases where this is true
        running = false;
        
        switch phase {
          case 0: // Jump at Player
            //at start of jump, plan the jump arc
            if phaseTimer == 0 {
                jump_count += 1; //increment jump counter
                image_index = 13; // set jumping sprite
                //Turn to face player
                if instance_exists(prtPlayer){
                    image_xscale = 1;
                    if x &gt; prtPlayer.x
                        image_xscale = -1;
                }
                // calculate yspeed:
                jump_type = irandom(2); //0: low, 1: medium, 2: high
                
                var jump_height, x_start, x_end, x_displacement, gravAccel;
                
                jump_height = jump_height_for[jump_type];
                
                gravAccel = cfgGravity*update_rate;
                
                // velocity required to reach jump height derived with kinematics equations:
                yspeed = -sqrt(abs(2*gravAccel*jump_height))
                airtime = abs(2*yspeed/gravAccel)
                
                // calculate xspeed:
                x_start = x;
                if instance_exists(prtPlayer)
                    x_end = prtPlayer.x + jump_x_offset[jump_type]*image_xscale;
                else
                    x_end = x;
                
                x_displacement = x_end - x_start;
                pref_xspeed = x_displacement / airtime; 
                //^^Added this variable for the case that Quick Man collides with a wall at the
                //beginning of a jump. He can now continue to try to move in that direction while 
                //in jump phase until over the wall, even tho xspeed is reset to 0
            }else if ground {
                //landed; restart jump (or next phase after 3 jumps)
                playSFX(sfxLand);
                if jump_count &gt;= 3 {
                    //next phase (running)
                    jump_count = 0;
                    phase = 1;
                    has_fired = false;
                }else{
                    //restart jump
                    startPhase = -1; //this will change phaseTimer to 0 at the end of the step
                }
            }
            //fire bullets at player
            //is this QM's 2nd jump, has he not fired yet, and is he about to fall from apex of jump
            if jump_count == 2 &amp;&amp; !has_fired &amp;&amp; yspeed&gt;= 0 &amp;&amp; instance_exists(prtPlayer){
                has_fired = true;
                //set shooting sprite
                image_index = 14;
                //fire bullet(s):
                var i;
                for (i=0;i&lt;3;i+=1){
                    with instance_create(x,y,objQuickManBoomerang){
                        var dir, target_x, target_y;
                        dir = point_direction(x,y,prtPlayer.x,prtPlayer.y); //intended direction of middle projectile
                        //here we add a correction to make the other two projectiles go 50% closer/farther in x-direction
                        _xspeed = cos(degtorad(dir))*_speed * (0.5+i/2);
                        _yspeed = -sin(degtorad(dir))*_speed;
                        dist = point_distance(x,y,x+(prtPlayer.x - x)*(0.5+i/2),prtPlayer.y)+48; //overshoot player position
                    }
                }
            }
            //Set xspeed to what we want before collision (^see notes above^)
            xspeed = pref_xspeed;
            break;
          case 1: // Run for 1 second
            if phaseTimer == 0 {
                //Turn to face player
                if instance_exists(prtPlayer){
                    image_xscale = 1;
                    if x &gt; prtPlayer.x
                        image_xscale = -1;
                }
            }
            xspeed = run_speed*image_xscale;
            running = true;
            // hop over small obstacle:
            if place_meeting(x,y+yspeed,objSolid) &amp;&amp; !place_meeting(x,y-6,objSolid)
            &amp;&amp; !place_meeting(x+xspeed,y+yspeed,objSolid) &amp;&amp; !place_meeting(x+xspeed,y+yspeed,objSolid) {
                // adjust position slightly:
                y-=6;
            }
            if phaseTimer &gt; run_time
                phase = 0;
            break;
        }
        
        //running animation
        if running {
            xDistanceTravelled += abs(xspeed);
            image_index = 8 + (xDistanceTravelled div 10) mod 4;
        }
        //check if the phase has changed and reset some variables
        phaseTimer += update_rate;
        if phase != startPhase {
            phaseTimer = 0;
        }
        generalCollision();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
