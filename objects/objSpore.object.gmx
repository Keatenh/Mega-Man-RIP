<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprSporeStand</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>sprPharaohmask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

name = "SPORE MAN";
level = rmSpore;
introBGCol = make_color_rgb(73, 89, 0);
introLineCol = make_color_rgb(138, 138, 0);
standSprite = sprSporeStand;
pose = sprSporePose;
poseImgSpeed = 3/60;
weaponID = objSporeDusterWeapon;
bossID = 0; //The ID on the stage select screen. The top-left has an ID of 0, then it goes clockwise (so the left panel's ID is 7)
            //The middle panel's ID is 8

contactDamage = 4;

global.weaponID = weaponID;
global.bossID = bossID;

//Weapon damages (only the ones different from default)
damage[objStarCrash] = 0;

damage[objSilverTomahawk] = 2;

damage[objWindStorm] = 5;

damage[objCentaurFlash] = 4;

damage[objTimeSlow] = 1;

ground = false;

phase = 0;
phaseTimer = 0; //The number of frames passed since the start of the phase
run_speed = 2;
run_time = 160; //60,100,240
xDistanceTravelled = 0; // how far the RM has moved, ever
jump_count = 0;
has_fired = false;
perched = false;
hide_time = 20;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if !global.frozen /*&amp;&amp; !global.flashStopper*/
{
    if isFight {      
        image_speed = 0;
        sprite_index = sprSporeStand;
        if perched {
            if (phase &lt; 2){ visible = false;} //only hide when perched in tree
            //sprite_index = sprSporeStand_Debug;
            ground = true;
            xspeed = 0;
            yspeed = 0;
            canHit = false;
        }else{
            visible = true;
            if (alarm[10] &lt;= 0){//Don't override invulernability from being hit
                canHit = true;
            }
            checkGround();
            gravityCheckGround();
        }
        //keep track of phase at start of step in case it changes
        startPhase = phase;
        
        //initialize so we only have to declare in phases where this is true
        running = false;
        
        switch phase {
          case 0: // Jump into tree/brush
            //at start of jump, plan the jump arc
            if phaseTimer == 0 {
                jump_count += 1; //increment jump counter
                //image_index = 13; // set jumping sprite
                //Turn to face player
                facePlayer();
                // calculate yspeed:
                if jump_count &lt;= 1 {
                    //on 1st jump, if Spore is in the middle half of the room,
                    // jump to the middle cover, else jump to the closest one
                    if ((x &lt; view_xview[0]+0.25*view_wview[0])){
                        cover_number = 0;   
                    }else if (x &gt; view_xview[0]+0.75*view_wview[0]){
                        cover_number = 2;
                    }else{
                        cover_number = 1;
                    }
                }else if jump_count == 2{
                    //Make a short jump to a nearby cover
                    cover_number = cover_number+1;
                    if cover_number &gt; 2 {cover_number = 1;} //if we get to R side, go back to middle
                }else if jump_count == 3{
                    //Make a long jump if possible, else make a random small jump
                    switch cover_number {
                        case 0:
                            cover_number = 2;
                        break;
                        case 1:
                            cover_number = choose(0,2);
                        break;
                        case 2:
                            cover_number = 0;
                        break;
                    }
                        
                }
                switch(cover_number){
                    case 0:
                        cover_position_x = 4128;
                        cover_position_y = 320;
                    break;
                    case 1:
                        cover_position_x = 4224;
                        cover_position_y = 272;
                    break;
                    case 2:
                        cover_position_x = 4304;
                        cover_position_y = 304;
                    break;   
                }
                var jump_height_position, gravAccel, time_1, time_2, yspeed_final;
                
                jump_height_position = 256; //264
                
                gravAccel = cfgGravity*update_rate;
                
                // velocity required to reach jump height derived with 
                // first est of kinematics equations:
                yspeed = -sqrt(abs(2*gravAccel*(jump_height_position-y)));
                time_1 = abs(yspeed/gravAccel);
                
                //horizontal velocity (constant throughout jump) derived with
                //2nd set of kinematics equations"
                yspeed_final = sqrt(2*gravAccel*(cover_position_y - jump_height_position));
                time_2 = yspeed_final/gravAccel;
                // calculate xspeed:
                xspeed = (cover_position_x - x)/(time_1+time_2); //previously pref_xspeed
                //^^Added this variable for the case that Quick Man collides with a wall at the
                //beginning of a jump. He can now continue to try to move in that direction while 
                //in jump phase until over the wall, even tho xspeed is reset to 0
            }else if ((yspeed &gt; 0) &amp;&amp; (y &gt;= cover_position_y)) { //detect when in position to hide in brush
                //landed; restart jump (or next phase after 3 jumps)
                //playSFX(sfxLand);
                dropLeaves(4,true);
                perched = true;
                phase = 1;
            }
            //Set xspeed to what we want before collision (^see notes above^)
            //xspeed = pref_xspeed;
            break;
          case 1: //pause, perched in brush
            if (phaseTimer &gt; hide_time) {
                perched = false;
                if (jump_count == 2){
                    phase = 2;
                }else if (jump_count == 3){
                    jump_count = 0; //reset jump count
                    phase = 3;
                }else{
                    phase = 0;
                }
            }
            break;
          case 2://fire bullets at player from cover
            if phaseTimer == 0 {
                if instance_exists(prtPlayer){
                    var i;
                    for (i=0;i&lt;3;i+=1){
                        with instance_create(x,y,objMM2Bullet){
                            //for example objMM2Bullet, this xscale variable is required, so we set it arbitrarily
                            xscale = 1;
                            dir = point_direction(x,y,prtPlayer.x,prtPlayer.y) + 30*(i-1); //intended direction of middle projectile
                        }
                    }
                }
            }else if phaseTimer &gt; (hide_time/2){
                phase = 0;
            }
            break;  
          case 3: // Run for 1 second
            if phaseTimer == 0 {
                //Turn to face player
                if instance_exists(prtPlayer){
                    image_xscale = 1;
                    if x &gt; prtPlayer.x
                        image_xscale = -1;
                }
            }
            xspeed = run_speed*image_xscale;
            running = true;
            //turn around if we are about to hit a wall
            if (place_meeting(x+xspeed,y,objSolid)){
                image_xscale = -image_xscale;
            }
            if phaseTimer &gt; run_time
                phase = 4;//0
            break;
            
          case 4: //jump 2 times before ending ground phase
            var xsp_prev = xspeed; //xspeed last frame (after collisions)
            xspeed = run_speed*image_xscale;
            if (place_meeting(x+xspeed,y,objSolid)){
                image_xscale = -image_xscale;
            }
            if phaseTimer == 0 {
                jump_count += 1;
                var jump_height, gravAccel;
                jump_height = 64;
                gravAccel = cfgGravity*update_rate;
                yspeed = -sqrt(abs(2*gravAccel*jump_height));
            }else if ground || (xsp_prev == 0 /*&amp;&amp; x &gt; view_xview[0]+.75*view_wview[0]*/) { //if we landed or hit the R side wall
                //restart jump (or next phase after x jumps)
                playSFX(sfxLand);
                if jump_count &gt;= 2 {
                    //next phase (shooting)
                    jump_count = 0;
                    phase = 5;
                    //has_fired = false;
                    if !ground { perched = true;}
                }else{
                    //restart jump
                    startPhase = -1; //this will change phaseTimer to 0 at the end of the step
                }
            }
            break;
          case 5: //shoot spore duster from the ground or perched on wall
            if phaseTimer == 0 {
                xspeed = 0; //stop running
                if ground {facePlayer();}
            }else if phaseTimer == hide_time+10 {
                if instance_exists(prtPlayer){
                    //if we are facing the x coord of player
                    if(image_xscale == sign(prtPlayer.x - x)){
                        with instance_create(x,y,objSporeManDuster) {
                            image_xscale = objSpore.image_xscale;
                            xspeed = 3*image_xscale;
                        }
                    }else{ // not facing player
                        //end phase early (if player manages to jump over Spore Man at the right time)
                        phase = 0;
                        perched = false;
                    }
                }
            }else if phaseTimer &gt; (3*hide_time){
                phase = 0;
                perched = false;
            }
            break;
        }
        
        //running animation
        if running {
            xDistanceTravelled += abs(xspeed);
            //image_index = 8 + (xDistanceTravelled div 10) mod 4;
        }
        //check if the phase has changed and reset some variables
        phaseTimer += update_rate;
        if phase != startPhase {
            phaseTimer = 0;
        }
        generalCollision();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="24">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Event: onHit - called when the enemy is hit

if phase == 3 { //running
    //make phase end more quickly
    phaseTimer += 10;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>13,13</point>
    <point>14,14</point>
  </PhysicsShapePoints>
</object>
